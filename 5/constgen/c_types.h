
  /* Идентифкаторы типов данных */
#define    vt_double         0      /* Вещественное */
#define    vt_bool           1      /* Булевское */
#define    vt_int            2      /* Целое */
#define    vt_pointer        3      /* Это тип - целое число зависящее от разрядности системы (для локальных переменных-указателей объектов) */

  /* Вспомогательные
  Вещественные */
#define    vt_float          4      /* 4 байтовое с ПЗ */
#define    vt_fix32          5      /* 4 байтовое fixpoint(16.16) */
  /* Целые */
#define    vt_int64          6      /* 64 битное целое */
#define    vt_int16          7      /* 16 битное целое */

#define    vt_complex        8      /* Комплексное из 2 64 битных вещественных */
#define    vt_complex_32     9      /* Комплексное из 2 32 битных вещественных */
#define    vt_complex_fix16 10      /* Комплексное из 2 32 битных вещественных с фиксированной точкой */

  /* Дополнительный тип - 8 битное значащее целое */
#define    vt_int8          11

  /* Беззначные целые типы данных */
#define    vt_uint8         12
#define    vt_uint16        13
#define    vt_uint32        14
#define    vt_uint64        15

  /* Направление переменной */
#define    dir_input         0
#define    dir_out           1
#define    dir_inout         2

  /* Флаги вызова run-функции блока */
#define    f_InitState       1      /* Запись начальных состояний */
#define    f_UpdateOuts      2      /* Обновить выходы на предварительном шаге */
#define    f_GoodStep        3      /* Обновить выходы на "хорошем" шаге */
#define    f_GetDeri         4      /* Вычислить значения правых частей дифференциальных уравнений */
#define    f_GetAlgFun       5      /* Вычислить значения правых частей алгебраических уравнений */
#define    f_SetState        6      /* Вычислить значения дискретных переменных состояния (после шага интегрирования) */
#define    f_UpdateProps     7      /* Обновить список параметров (с учётом флага изменяемости) */
#define    f_GetJacobyState  8      /* Вычислить значения дискретных переменных состояния при расчете Якобиана */
#define    f_UpdateJacoby    9      /* Обновить Якобиан блока */
#define    f_RestoreOuts    10      /* Обновить выходы после рестарта (только если очень надо, т.к. выходы всё равно будут запоминаться) */
#define    f_SetAlgOut      11      /* Выставить выходы блока, содержащих алгебраические переменные */
#define    f_InitAlgState   12      /* Выставить начальное приближение для алгебраические переменных */
#define    f_Stop           13      /* Вызывается при остановке расчёта (конец моделирования) */
#define    f_InitObjects    14      /* Инициализация объектов, массивов и т.д. (сразу после сортировки) (начало моделирования) */

  /* Флаги вызовов информационной функции блока */ 
#define    i_GetBlockType    1      /* Получить тип блока (источник, динамический и т.д */
#define    i_GetDifCount     2      /* Получить число дифференциальных переменных */
#define    i_GetDisCount     3      /* Если Result > 0 то обрабатывается флаг f_SetState */
#define    i_GetAlgCount     4      /* Получить число алгебраических переменных */
#define    i_GetCount        5      /* Получить размерности входов\выходов */
#define    i_GetInit         6      /* Получить флаг зависимости выходов от входов */
#define    i_GetPropErr      7      /* Проверка правильности задания параметров блока (перед сортировкой) */
#define    i_HaveSpetialEditor  8   /* Флаг - run-объект имеет специализированный редактор блока */

  /* Типы блоков (для сортировки, частотного анализа, синтеза) */
#define    t_none              0    /* Сервисный блок, в расчете не участвует */
#define    t_src               1    /* Блок-источник сигнала */
#define    t_fun               2    /* Функциональный блок */
#define    t_dst               3    /* Блок-приемник информации */
#define    t_del               4    /* Блоки запаздывания */
#define    t_ext               5    /* Блоки-экстраполяторы */
#define    t_der               6    /* Блоки-производные */
#define    t_imp               7    /* Блоки-импортеры данных */
#define    t_exp               8    /* Блоки-экспортеры данных */

  /* Возможные результаты функций */
#define    r_Success        0       /* Нет ошибки */
#define    r_Fail           1       /* Возникла ошибка */

  /* Макрос - экспорт функции в DLL */
#define EXPORTED_FUNC int

  /* Комплексное двойной точности */
typedef struct { 
 double re;
 double im;
} complex_64;

  /* Комплексное одинарной точности */
typedef struct { 
 float re;
 float im;
} complex_32;

  /* Запись переменной */
typedef struct {
  char* name;
  int   data_type;
  int   dim[3];
  int   index;
  int   direction;
  char* description;
  void* default_ptr;
  int   data_size;
} ext_var_info_record;

typedef int (*t_glob_obj_destructor_proc)(void* aGlobalObjPtr);

  /* Описание структуры для доступа к специальным переменным и методам решателя */
typedef struct {
  void*   LayerContext;                  /* Указатель на контекст решателя */
    /* Параметры интегрирования - передаются извне */
  char    IntMet;                        /* Метод интегрирования */
  char    LoopMet;                       /* Метод решения системы НАУ */
  char    IsLoop;                        /* Флаг метода интегрирования (явный или неявный) - для явных - True */
  int     MaxLoopIt;                     /* Максимальное число итераций при решении системы НАУ */
  double  AbsErr;                        /* Абсолютная ошибка */
  double  RelErr;                        /* Относительная ошибка */
  double  Hmin;                          /* Минимальный шаг интегрирования */
  double  Hmax;                          /* Максимальный шаг интегрирования */
    /*Параметры, задающие тип синхронизации расчета */
  char    fPrecition;                    /* Флаг точной синхронизации */
  char    fOneStep;                      /* Флаг выполнения одного шага интегрирования */
  char    fFirstStep;                    /* Флаг первого шага расчёта */
    /*Переменные управления решателем */
  double  newstep;                       /* Новый прогнозный шаг интегрирования */
  char    fsetstep;                      /* Флаг - установить новый шаг интегрирования */
    /* Эти методы используются для того чтобы зарегситрировать и удалить
    специализированные объекты схемы (например распределённый решатель лин. уравнений)
    Найти глобальный объект по имени    */
  void*   (*FindGlobalObject)(void* ALayerContext,char* aGlobObjectName);
    /* Зарегистрировать новый глобальный объект */
  void    (*RegisterGlobalObject)(void* ALayerContext,char* aGlobObjectName,void* aNewObject,t_glob_obj_destructor_proc destructor_proc_ptr);
    /* Регистрация нужной библиотеки и получение от неё функций */
  unsigned int (*DoLoadNeedPlugin)(char* aPluginName);    
    /* Флаг необходимости повторного шага  */
  char    fNeedIter;  
    /* Контрольная сумма структуры текущей схемы (для проверки совпадения со сгенерированным кодом) */
  unsigned int  ShemeHash;
    /* Ссылка на глобальные списки именованных зависимостей и соотв-й хеш-лист */
  void*   GlobalDepList;
  void*   GlobalDepHash;
    /* Флаг учёта расширенных зависимостей сортировки для блоков чтения и записи сигналов */
  char    UseSignalExtendedSort;
    /* Флаг - ошибка при наличии алгебраических петель образованных блоками чтения и записи сигналов */
  char    ErrorOnSignalLoop;
    /* Учёт зависимостей сортировки блоков типа "Условие выполенния субмодели" */
  char    UseConditionsExtendedSort;
    /* Текущий список зависимостей для записи дополнительных данных */
  void*   CurentDepList;
    /* Ссылка на список замены портов для оптимизации передачи данных */
  void*   GlobalWherewithList;
  void*   GlobalWherewithHash;
    /* Использовать замену портов при оптимизации связок "чтение сигналов"-"запись сигналов" */
  char    UseSignalsPortReconnection;
    /* Флаг режима проверки констант */
  char    fConstantCheckMode;
    /* Флаг режима генерации кода - для блокировки работы некоторых блоков */
  char    fCodeGenMode;
    /* Указатель контекста задачи, необходимый для некоторых функций */
  void*   TaskContext;
    /* Функция поиска указателя на данные по имени объекта, возврат = тип данных, и указатель */
  unsigned char  (*GetDataPtr)(void* TaskContext, char* aSignalName, void** DataPtr, int* dimension); 
    /* Проверка необходимости принудительной остановки  */
  char    (*StopCheck)(void* TaskContext);  
    /* Флаг - блоки записи выполнять только на шаге синхронизации */
  char    WriteSignalsOnSyncStep;
    /* Флаг - транслировать сигналы из\в внешней исполнительной системы */
  char    common_translation_flag;
    /* Указатель на глобальную переменную текущего времени */
  double* fCurentTime;
    /* Указатель на глобальную переменную - текущий шаг решателя */
  double* fCurentStep;
    /* Флаг - необходимо перезапустить расчёт с нулевой точки заново */
  char    fStartAgain;
    /* Флаг - необходимо запомнить стартовое состояние модели */
  char    fSaveModelState;
    /* Флаг - нужно перезаписывать значения сигналов на выходах при вызове f_InitState */
  char    fWriteSignalsOnInitState;
    /* Флаг - использовать контроль точности для алгебраических переменных для DIRK и явных методов */
  char    UseAlgVarsStepControl;
    /* Количество текущих локальных итераций (для распределённого анализа точности) */
  int     NLocalIter;
    /* Флаг - делать дополнительные пробные шаги для внутренних итераций модели
       При наличии блоков анализа точности и повтора расчёта надо выставить этот флаг, чтобы
       перед выполнением f_GoodStep делался f_UpdateOuts с тем же шагом интегрирования  */
  char    fNeedUpdateOutsBeforeGoodStep;  
    /* Флаг - использовать уточнение шага для разрывных источников сигнала */
  char    fPreciseSrcStep;   

    /* Имя библиотеки решения разреженной СЛАУ  */  
  char*   DefaultLAESolverLibraryName;
    
} solver_struct;






